{"version":3,"file":"livekit-client.e2ee.worker.js","sources":["../node_modules/.pnpm/loglevel@1.8.1/node_modules/loglevel/lib/loglevel.js","../src/logger.ts","../src/e2ee/constants.ts","../src/room/errors.ts","../src/e2ee/errors.ts","../src/e2ee/events.ts","../node_modules/.pnpm/events@3.3.0/node_modules/events/events.js","../src/e2ee/utils.ts","../src/e2ee/worker/SifGuard.ts","../src/e2ee/worker/FrameCryptor.ts","../src/e2ee/worker/ParticipantKeyHandler.ts","../src/e2ee/worker/e2ee.worker.ts"],"sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n        /*jshint validthis:true */\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, loggerName);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this, level, loggerName);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var location = cookie.indexOf(\n                      encodeURIComponent(storageKey) + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          return currentLevel;\n      };\n\n      self.setLevel = function (level, persist) {\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              currentLevel = level;\n              if (persist !== false) {  // defaults to true\n                  persistLevelIfPossible(level);\n              }\n              replaceLoggingMethods.call(self, level, name);\n              if (typeof console === undefinedType && level < self.levels.SILENT) {\n                  return \"No console available for logging\";\n              }\n          } else {\n              throw \"log.setLevel() called with invalid level: \" + level;\n          }\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = level;\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          self.setLevel(defaultLevel, false);\n          clearPersistedLevel();\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n          initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n          throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n          logger = _loggersByName[name] = new Logger(\n            name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","import * as log from 'loglevel';\n\nexport enum LogLevel {\n  trace = 0,\n  debug = 1,\n  info = 2,\n  warn = 3,\n  error = 4,\n  silent = 5,\n}\n\nexport enum LoggerNames {\n  Default = 'livekit',\n  Room = 'livekit-room',\n  Participant = 'livekit-participant',\n  Track = 'livekit-track',\n  Publication = 'livekit-track-publication',\n  Engine = 'livekit-engine',\n  Signal = 'livekit-signal',\n  PCManager = 'livekit-pc-manager',\n  PCTransport = 'livekit-pc-transport',\n  E2EE = 'lk-e2ee',\n}\n\ntype LogLevelString = keyof typeof LogLevel;\n\nexport type StructuredLogger = log.Logger & {\n  trace: (msg: string, context?: object) => void;\n  debug: (msg: string, context?: object) => void;\n  info: (msg: string, context?: object) => void;\n  warn: (msg: string, context?: object) => void;\n  error: (msg: string, context?: object) => void;\n  setDefaultLevel: (level: log.LogLevelDesc) => void;\n  setLevel: (level: log.LogLevelDesc) => void;\n  getLevel: () => number;\n};\n\nlet livekitLogger = log.getLogger('livekit');\nconst livekitLoggers = Object.values(LoggerNames).map((name) => log.getLogger(name));\n\nlivekitLogger.setDefaultLevel(LogLevel.info);\n\nexport default livekitLogger as StructuredLogger;\n\n/**\n * @internal\n */\nexport function getLogger(name: string) {\n  const logger = log.getLogger(name);\n  logger.setDefaultLevel(livekitLogger.getLevel());\n  return logger as StructuredLogger;\n}\n\nexport function setLogLevel(level: LogLevel | LogLevelString, loggerName?: LoggerNames) {\n  if (loggerName) {\n    log.getLogger(loggerName).setLevel(level);\n  }\n  for (const logger of livekitLoggers) {\n    logger.setLevel(level);\n  }\n}\n\nexport type LogExtension = (level: LogLevel, msg: string, context?: object) => void;\n\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */\nexport function setLogExtension(extension: LogExtension, logger?: StructuredLogger) {\n  const loggers = logger ? [logger] : livekitLoggers;\n\n  loggers.forEach((logR) => {\n    const originalFactory = logR.methodFactory;\n\n    logR.methodFactory = (methodName, configLevel, loggerName) => {\n      const rawMethod = originalFactory(methodName, configLevel, loggerName);\n\n      const logLevel = LogLevel[methodName as LogLevelString];\n      const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n\n      return (msg, context?: [msg: string, context: object]) => {\n        if (context) rawMethod(msg, context);\n        else rawMethod(msg);\n        if (needLog) {\n          extension(logLevel, msg, context);\n        }\n      };\n    };\n    logR.setLevel(logR.getLevel());\n  });\n}\n\nexport const workerLogger = log.getLogger('lk-e2ee') as StructuredLogger;\n","import type { KeyProviderOptions } from './types';\n\nexport const ENCRYPTION_ALGORITHM = 'AES-GCM';\n\n// We use a ringbuffer of keys so we can change them and still decode packets that were\n// encrypted with an old key. We use a size of 16 which corresponds to the four bits\n// in the frame trailer.\nexport const KEYRING_SIZE = 16;\n\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nexport const DECRYPTION_FAILURE_TOLERANCE = 10;\n\n// We copy the first bytes of the VP8 payload unencrypted.\n// For keyframes this is 10 bytes, for non-keyframes (delta) 3. See\n//   https://tools.ietf.org/html/rfc6386#section-9.1\n// This allows the bridge to continue detecting keyframes (only one byte needed in the JVB)\n// and is also a bit easier for the VP8 decoder (i.e. it generates funny garbage pictures\n// instead of being unable to decode).\n// This is a bit for show and we might want to reduce to 1 unconditionally in the final version.\n//\n// For audio (where frame.type is not set) we do not encrypt the opus TOC byte:\n//   https://tools.ietf.org/html/rfc6716#section-3.1\nexport const UNENCRYPTED_BYTES = {\n  key: 10,\n  delta: 3,\n  audio: 1, // frame.type is not set on audio, so this is set manually\n  empty: 0,\n} as const;\n\n/* We use a 12 byte bit IV. This is signalled in plain together with the\n packet. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters */\nexport const IV_LENGTH = 12;\n\n// flag set to indicate that e2ee has been setup for sender/receiver;\nexport const E2EE_FLAG = 'lk_e2ee';\n\nexport const SALT = 'LKFrameEncryptionKey';\n\nexport const KEY_PROVIDER_DEFAULTS: KeyProviderOptions = {\n  sharedKey: false,\n  ratchetSalt: SALT,\n  ratchetWindowSize: 8,\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n} as const;\n\nexport const MAX_SIF_COUNT = 100;\nexport const MAX_SIF_DURATION = 2000;\n","export class LivekitError extends Error {\n  code: number;\n\n  constructor(code: number, message?: string) {\n    super(message || 'an error has occured');\n    this.code = code;\n  }\n}\n\nexport const enum ConnectionErrorReason {\n  NotAllowed,\n  ServerUnreachable,\n  InternalError,\n  Cancelled,\n  LeaveRequest,\n}\n\nexport class ConnectionError extends LivekitError {\n  status?: number;\n\n  reason?: ConnectionErrorReason;\n\n  constructor(message?: string, reason?: ConnectionErrorReason, status?: number) {\n    super(1, message);\n    this.status = status;\n    this.reason = reason;\n  }\n}\n\nexport class DeviceUnsupportedError extends LivekitError {\n  constructor(message?: string) {\n    super(21, message ?? 'device is unsupported');\n  }\n}\n\nexport class TrackInvalidError extends LivekitError {\n  constructor(message?: string) {\n    super(20, message ?? 'track is invalid');\n  }\n}\n\nexport class UnsupportedServer extends LivekitError {\n  constructor(message?: string) {\n    super(10, message ?? 'unsupported server');\n  }\n}\n\nexport class UnexpectedConnectionState extends LivekitError {\n  constructor(message?: string) {\n    super(12, message ?? 'unexpected connection state');\n  }\n}\n\nexport class NegotiationError extends LivekitError {\n  constructor(message?: string) {\n    super(13, message ?? 'unable to negotiate');\n  }\n}\n\nexport class PublishDataError extends LivekitError {\n  constructor(message?: string) {\n    super(13, message ?? 'unable to publish data');\n  }\n}\n\nexport enum MediaDeviceFailure {\n  // user rejected permissions\n  PermissionDenied = 'PermissionDenied',\n  // device is not available\n  NotFound = 'NotFound',\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\n  DeviceInUse = 'DeviceInUse',\n  Other = 'Other',\n}\n\nexport namespace MediaDeviceFailure {\n  export function getFailure(error: any): MediaDeviceFailure | undefined {\n    if (error && 'name' in error) {\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        return MediaDeviceFailure.NotFound;\n      }\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        return MediaDeviceFailure.PermissionDenied;\n      }\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        return MediaDeviceFailure.DeviceInUse;\n      }\n      return MediaDeviceFailure.Other;\n    }\n  }\n}\n","import { LivekitError } from '../room/errors';\n\nexport enum CryptorErrorReason {\n  InvalidKey = 0,\n  MissingKey = 1,\n  InternalError = 2,\n}\n\nexport class CryptorError extends LivekitError {\n  reason: CryptorErrorReason;\n\n  constructor(message?: string, reason: CryptorErrorReason = CryptorErrorReason.InternalError) {\n    super(40, message);\n    this.reason = reason;\n  }\n}\n","import type Participant from '../room/participant/Participant';\nimport type { CryptorError } from './errors';\nimport type { KeyInfo } from './types';\n\nexport enum KeyProviderEvent {\n  SetKey = 'setKey',\n  RatchetRequest = 'ratchetRequest',\n  KeyRatcheted = 'keyRatcheted',\n}\n\nexport type KeyProviderCallbacks = {\n  [KeyProviderEvent.SetKey]: (keyInfo: KeyInfo) => void;\n  [KeyProviderEvent.RatchetRequest]: (participantIdentity?: string, keyIndex?: number) => void;\n  [KeyProviderEvent.KeyRatcheted]: (material: CryptoKey, keyIndex?: number) => void;\n};\n\nexport enum KeyHandlerEvent {\n  KeyRatcheted = 'keyRatcheted',\n}\n\nexport type ParticipantKeyHandlerCallbacks = {\n  [KeyHandlerEvent.KeyRatcheted]: (\n    material: CryptoKey,\n    participantIdentity: string,\n    keyIndex?: number,\n  ) => void;\n};\n\nexport enum EncryptionEvent {\n  ParticipantEncryptionStatusChanged = 'participantEncryptionStatusChanged',\n  EncryptionError = 'encryptionError',\n}\n\nexport type E2EEManagerCallbacks = {\n  [EncryptionEvent.ParticipantEncryptionStatusChanged]: (\n    enabled: boolean,\n    participant: Participant,\n  ) => void;\n  [EncryptionEvent.EncryptionError]: (error: Error) => void;\n};\n\nexport type CryptorCallbacks = {\n  [CryptorEvent.Error]: (error: CryptorError) => void;\n};\n\nexport enum CryptorEvent {\n  Error = 'cryptorError',\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n","import { ENCRYPTION_ALGORITHM } from './constants';\n\nexport function isE2EESupported() {\n  return isInsertableStreamSupported() || isScriptTransformSupported();\n}\n\nexport function isScriptTransformSupported() {\n  // @ts-ignore\n  return typeof window.RTCRtpScriptTransform !== 'undefined';\n}\n\nexport function isInsertableStreamSupported() {\n  return (\n    typeof window.RTCRtpSender !== 'undefined' &&\n    // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== 'undefined'\n  );\n}\n\nexport function isVideoFrame(\n  frame: RTCEncodedAudioFrame | RTCEncodedVideoFrame,\n): frame is RTCEncodedVideoFrame {\n  return 'type' in frame;\n}\n\nexport async function importKey(\n  keyBytes: Uint8Array | ArrayBuffer,\n  algorithm: string | { name: string } = { name: ENCRYPTION_ALGORITHM },\n  usage: 'derive' | 'encrypt' = 'encrypt',\n) {\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n  return crypto.subtle.importKey(\n    'raw',\n    keyBytes,\n    algorithm,\n    false,\n    usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt'],\n  );\n}\n\nexport async function createKeyMaterialFromString(password: string) {\n  let enc = new TextEncoder();\n\n  const keyMaterial = await crypto.subtle.importKey(\n    'raw',\n    enc.encode(password),\n    {\n      name: 'PBKDF2',\n    },\n    false,\n    ['deriveBits', 'deriveKey'],\n  );\n\n  return keyMaterial;\n}\n\nexport async function createKeyMaterialFromBuffer(cryptoBuffer: ArrayBuffer) {\n  const keyMaterial = await crypto.subtle.importKey('raw', cryptoBuffer, 'HKDF', false, [\n    'deriveBits',\n    'deriveKey',\n  ]);\n\n  return keyMaterial;\n}\n\nfunction getAlgoOptions(algorithmName: string, salt: string) {\n  const textEncoder = new TextEncoder();\n  const encodedSalt = textEncoder.encode(salt);\n  switch (algorithmName) {\n    case 'HKDF':\n      return {\n        name: 'HKDF',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        info: new ArrayBuffer(128),\n      };\n    case 'PBKDF2': {\n      return {\n        name: 'PBKDF2',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        iterations: 100000,\n      };\n    }\n    default:\n      throw new Error(`algorithm ${algorithmName} is currently unsupported`);\n  }\n}\n\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nexport async function deriveKeys(material: CryptoKey, salt: string) {\n  const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n  // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n  const encryptionKey = await crypto.subtle.deriveKey(\n    algorithmOptions,\n    material,\n    {\n      name: ENCRYPTION_ALGORITHM,\n      length: 128,\n    },\n    false,\n    ['encrypt', 'decrypt'],\n  );\n\n  return { material, encryptionKey };\n}\n\nexport function createE2EEKey(): Uint8Array {\n  return window.crypto.getRandomValues(new Uint8Array(32));\n}\n\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */\nexport async function ratchet(material: CryptoKey, salt: string): Promise<ArrayBuffer> {\n  const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n  return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n}\n\nexport function needsRbspUnescaping(frameData: Uint8Array) {\n  for (var i = 0; i < frameData.length - 3; i++) {\n    if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n  }\n  return false;\n}\n\nexport function parseRbsp(stream: Uint8Array): Uint8Array {\n  const dataOut: number[] = [];\n  var length = stream.length;\n  for (var i = 0; i < stream.length; ) {\n    // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n    // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n    // above, and that expression will produce the number of bytes left in\n    // the stream including the byte at i.\n    if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n      // Two rbsp bytes.\n      dataOut.push(stream[i++]);\n      dataOut.push(stream[i++]);\n      // Skip the emulation byte.\n      i++;\n    } else {\n      // Single rbsp byte.\n      dataOut.push(stream[i++]);\n    }\n  }\n  return new Uint8Array(dataOut);\n}\n\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\n\nexport function writeRbsp(data_in: Uint8Array): Uint8Array {\n  const dataOut: number[] = [];\n  var numConsecutiveZeros = 0;\n  for (var i = 0; i < data_in.length; ++i) {\n    var byte = data_in[i];\n    if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n      // Need to escape.\n      dataOut.push(kEmulationByte);\n      numConsecutiveZeros = 0;\n    }\n    dataOut.push(byte);\n    if (byte == 0) {\n      ++numConsecutiveZeros;\n    } else {\n      numConsecutiveZeros = 0;\n    }\n  }\n  return new Uint8Array(dataOut);\n}\n","import { MAX_SIF_COUNT, MAX_SIF_DURATION } from '../constants';\n\nexport class SifGuard {\n  private consecutiveSifCount = 0;\n\n  private sifSequenceStartedAt: number | undefined;\n\n  private lastSifReceivedAt: number = 0;\n\n  private userFramesSinceSif: number = 0;\n\n  recordSif() {\n    this.consecutiveSifCount += 1;\n    this.sifSequenceStartedAt ??= Date.now();\n    this.lastSifReceivedAt = Date.now();\n  }\n\n  recordUserFrame() {\n    if (this.sifSequenceStartedAt === undefined) {\n      return;\n    } else {\n      this.userFramesSinceSif += 1;\n    }\n    if (\n      // reset if we received more user frames than SIFs\n      this.userFramesSinceSif > this.consecutiveSifCount ||\n      // also reset if we got a new user frame and the latest SIF frame hasn't been updated in a while\n      Date.now() - this.lastSifReceivedAt > MAX_SIF_DURATION\n    ) {\n      this.reset();\n    }\n  }\n\n  isSifAllowed() {\n    return (\n      this.consecutiveSifCount < MAX_SIF_COUNT &&\n      (this.sifSequenceStartedAt === undefined ||\n        Date.now() - this.sifSequenceStartedAt < MAX_SIF_DURATION)\n    );\n  }\n\n  reset() {\n    this.userFramesSinceSif = 0;\n    this.consecutiveSifCount = 0;\n    this.sifSequenceStartedAt = undefined;\n  }\n}\n","/* eslint-disable @typescript-eslint/no-unused-vars */\n// TODO code inspired by https://github.com/webrtc/samples/blob/gh-pages/src/content/insertable-streams/endtoend-encryption/js/worker.js\nimport { EventEmitter } from 'events';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { workerLogger } from '../../logger';\nimport type { VideoCodec } from '../../room/track/options';\nimport { ENCRYPTION_ALGORITHM, IV_LENGTH, UNENCRYPTED_BYTES } from '../constants';\nimport { CryptorError, CryptorErrorReason } from '../errors';\nimport { CryptorCallbacks, CryptorEvent } from '../events';\nimport type { DecodeRatchetOptions, KeyProviderOptions, KeySet } from '../types';\nimport { deriveKeys, isVideoFrame, needsRbspUnescaping, parseRbsp, writeRbsp } from '../utils';\nimport type { ParticipantKeyHandler } from './ParticipantKeyHandler';\nimport { SifGuard } from './SifGuard';\n\nexport const encryptionEnabledMap: Map<string, boolean> = new Map();\n\nexport interface FrameCryptorConstructor {\n  new (opts?: unknown): BaseFrameCryptor;\n}\n\nexport interface TransformerInfo {\n  readable: ReadableStream;\n  writable: WritableStream;\n  transformer: TransformStream;\n  abortController: AbortController;\n}\n\nexport class BaseFrameCryptor extends (EventEmitter as new () => TypedEventEmitter<CryptorCallbacks>) {\n  protected encodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ): Promise<any> {\n    throw Error('not implemented for subclass');\n  }\n\n  protected decodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ): Promise<any> {\n    throw Error('not implemented for subclass');\n  }\n}\n\n/**\n * Cryptor is responsible for en-/decrypting media frames.\n * Each Cryptor instance is responsible for en-/decrypting a single mediaStreamTrack.\n */\nexport class FrameCryptor extends BaseFrameCryptor {\n  private sendCounts: Map<number, number>;\n\n  private participantIdentity: string | undefined;\n\n  private trackId: string | undefined;\n\n  private keys: ParticipantKeyHandler;\n\n  private videoCodec?: VideoCodec;\n\n  private rtpMap: Map<number, VideoCodec>;\n\n  private keyProviderOptions: KeyProviderOptions;\n\n  /**\n   * used for detecting server injected unencrypted frames\n   */\n  private sifTrailer: Uint8Array;\n\n  private sifGuard: SifGuard;\n\n  private detectedCodec?: VideoCodec;\n\n  constructor(opts: {\n    keys: ParticipantKeyHandler;\n    participantIdentity: string;\n    keyProviderOptions: KeyProviderOptions;\n    sifTrailer?: Uint8Array;\n  }) {\n    super();\n    this.sendCounts = new Map();\n    this.keys = opts.keys;\n    this.participantIdentity = opts.participantIdentity;\n    this.rtpMap = new Map();\n    this.keyProviderOptions = opts.keyProviderOptions;\n    this.sifTrailer = opts.sifTrailer ?? Uint8Array.from([]);\n    this.sifGuard = new SifGuard();\n  }\n\n  private get logContext() {\n    return {\n      participant: this.participantIdentity,\n      mediaTrackId: this.trackId,\n      fallbackCodec: this.videoCodec,\n    };\n  }\n\n  /**\n   * Assign a different participant to the cryptor.\n   * useful for transceiver re-use\n   * @param id\n   * @param keys\n   */\n  setParticipant(id: string, keys: ParticipantKeyHandler) {\n    this.participantIdentity = id;\n    this.keys = keys;\n    this.sifGuard.reset();\n  }\n\n  unsetParticipant() {\n    workerLogger.debug('unsetting participant', this.logContext);\n    this.participantIdentity = undefined;\n  }\n\n  isEnabled() {\n    if (this.participantIdentity) {\n      return encryptionEnabledMap.get(this.participantIdentity);\n    } else {\n      return undefined;\n    }\n  }\n\n  getParticipantIdentity() {\n    return this.participantIdentity;\n  }\n\n  getTrackId() {\n    return this.trackId;\n  }\n\n  /**\n   * Update the video codec used by the mediaStreamTrack\n   * @param codec\n   */\n  setVideoCodec(codec: VideoCodec) {\n    this.videoCodec = codec;\n  }\n\n  /**\n   * rtp payload type map used for figuring out codec of payload type when encoding\n   * @param map\n   */\n  setRtpMap(map: Map<number, VideoCodec>) {\n    this.rtpMap = map;\n  }\n\n  setupTransform(\n    operation: 'encode' | 'decode',\n    readable: ReadableStream,\n    writable: WritableStream,\n    trackId: string,\n    codec?: VideoCodec,\n  ) {\n    if (codec) {\n      workerLogger.info('setting codec on cryptor to', { codec });\n      this.videoCodec = codec;\n    }\n\n    workerLogger.debug('Setting up frame cryptor transform', {\n      operation,\n      passedTrackId: trackId,\n      codec,\n      ...this.logContext,\n    });\n\n    const transformFn = operation === 'encode' ? this.encodeFunction : this.decodeFunction;\n    const transformStream = new TransformStream({\n      transform: transformFn.bind(this),\n    });\n\n    readable\n      .pipeThrough(transformStream)\n      .pipeTo(writable)\n      .catch((e) => {\n        workerLogger.warn(e);\n        this.emit(CryptorEvent.Error, e instanceof CryptorError ? e : new CryptorError(e.message));\n      });\n    this.trackId = trackId;\n  }\n\n  setSifTrailer(trailer: Uint8Array) {\n    workerLogger.debug('setting SIF trailer', { ...this.logContext, trailer });\n    this.sifTrailer = trailer;\n  }\n\n  /**\n   * Function that will be injected in a stream and will encrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   *\n   * The VP8 payload descriptor described in\n   * https://tools.ietf.org/html/rfc7741#section-4.2\n   * is part of the RTP packet and not part of the frame and is not controllable by us.\n   * This is fine as the SFU keeps having access to it for routing.\n   *\n   * The encrypted frame is formed as follows:\n   * 1) Find unencrypted byte length, depending on the codec, frame type and kind.\n   * 2) Form the GCM IV for the frame as described above.\n   * 3) Encrypt the rest of the frame using AES-GCM.\n   * 4) Allocate space for the encrypted frame.\n   * 5) Copy the unencrypted bytes to the start of the encrypted frame.\n   * 6) Append the ciphertext to the encrypted frame.\n   * 7) Append the IV.\n   * 8) Append a single byte for the key identifier.\n   * 9) Enqueue the encrypted frame for sending.\n   */\n  protected async encodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ) {\n    if (\n      !this.isEnabled() ||\n      // skip for encryption for empty dtx frames\n      encodedFrame.data.byteLength === 0\n    ) {\n      return controller.enqueue(encodedFrame);\n    }\n    const keySet = this.keys.getKeySet();\n    if (!keySet) {\n      throw new TypeError(\n        `key set not found for ${\n          this.participantIdentity\n        } at index ${this.keys.getCurrentKeyIndex()}`,\n      );\n    }\n    const { encryptionKey } = keySet;\n    const keyIndex = this.keys.getCurrentKeyIndex();\n\n    if (encryptionKey) {\n      const iv = this.makeIV(\n        encodedFrame.getMetadata().synchronizationSource ?? -1,\n        encodedFrame.timestamp,\n      );\n      let frameInfo = this.getUnencryptedBytes(encodedFrame);\n\n      // Thіs is not encrypted and contains the VP8 payload descriptor or the Opus TOC byte.\n      const frameHeader = new Uint8Array(encodedFrame.data, 0, frameInfo.unencryptedBytes);\n\n      // Frame trailer contains the R|IV_LENGTH and key index\n      const frameTrailer = new Uint8Array(2);\n\n      frameTrailer[0] = IV_LENGTH;\n      frameTrailer[1] = keyIndex;\n\n      // Construct frame trailer. Similar to the frame header described in\n      // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n      // but we put it at the end.\n      //\n      // ---------+-------------------------+-+---------+----\n      // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n      // ---------+-------------------------+-+---------+----\n      try {\n        const cipherText = await crypto.subtle.encrypt(\n          {\n            name: ENCRYPTION_ALGORITHM,\n            iv,\n            additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength),\n          },\n          encryptionKey,\n          new Uint8Array(encodedFrame.data, frameInfo.unencryptedBytes),\n        );\n\n        let newDataWithoutHeader = new Uint8Array(\n          cipherText.byteLength + iv.byteLength + frameTrailer.byteLength,\n        );\n        newDataWithoutHeader.set(new Uint8Array(cipherText)); // add ciphertext.\n        newDataWithoutHeader.set(new Uint8Array(iv), cipherText.byteLength); // append IV.\n        newDataWithoutHeader.set(frameTrailer, cipherText.byteLength + iv.byteLength); // append frame trailer.\n\n        if (frameInfo.isH264) {\n          newDataWithoutHeader = writeRbsp(newDataWithoutHeader);\n        }\n\n        var newData = new Uint8Array(frameHeader.byteLength + newDataWithoutHeader.byteLength);\n        newData.set(frameHeader);\n        newData.set(newDataWithoutHeader, frameHeader.byteLength);\n\n        encodedFrame.data = newData.buffer;\n\n        return controller.enqueue(encodedFrame);\n      } catch (e: any) {\n        // TODO: surface this to the app.\n        workerLogger.error(e);\n      }\n    } else {\n      workerLogger.debug('failed to decrypt, emitting error', this.logContext);\n      this.emit(\n        CryptorEvent.Error,\n        new CryptorError(`encryption key missing for encoding`, CryptorErrorReason.MissingKey),\n      );\n    }\n  }\n\n  /**\n   * Function that will be injected in a stream and will decrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   */\n  protected async decodeFunction(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController,\n  ) {\n    if (\n      !this.isEnabled() ||\n      // skip for decryption for empty dtx frames\n      encodedFrame.data.byteLength === 0\n    ) {\n      workerLogger.debug('skipping empty frame', this.logContext);\n      this.sifGuard.recordUserFrame();\n      return controller.enqueue(encodedFrame);\n    }\n\n    if (isFrameServerInjected(encodedFrame.data, this.sifTrailer)) {\n      workerLogger.debug('enqueue SIF', this.logContext);\n      this.sifGuard.recordSif();\n\n      if (this.sifGuard.isSifAllowed()) {\n        encodedFrame.data = encodedFrame.data.slice(\n          0,\n          encodedFrame.data.byteLength - this.sifTrailer.byteLength,\n        );\n        return controller.enqueue(encodedFrame);\n      } else {\n        workerLogger.warn('SIF limit reached, dropping frame');\n        return;\n      }\n    } else {\n      this.sifGuard.recordUserFrame();\n    }\n    const data = new Uint8Array(encodedFrame.data);\n    const keyIndex = data[encodedFrame.data.byteLength - 1];\n\n    if (this.keys.getKeySet(keyIndex) && this.keys.hasValidKey) {\n      try {\n        const decodedFrame = await this.decryptFrame(encodedFrame, keyIndex);\n        this.keys.decryptionSuccess();\n        if (decodedFrame) {\n          return controller.enqueue(decodedFrame);\n        }\n      } catch (error) {\n        if (error instanceof CryptorError && error.reason === CryptorErrorReason.InvalidKey) {\n          if (this.keys.hasValidKey) {\n            this.emit(CryptorEvent.Error, error);\n            this.keys.decryptionFailure();\n          }\n        } else {\n          workerLogger.warn('decoding frame failed', { error });\n        }\n      }\n    } else if (!this.keys.getKeySet(keyIndex) && this.keys.hasValidKey) {\n      // emit an error in case the key index is out of bounds but the key handler thinks we still have a valid key\n      workerLogger.warn(`skipping decryption due to missing key at index ${keyIndex}`);\n      this.emit(\n        CryptorEvent.Error,\n        new CryptorError(\n          `missing key at index ${keyIndex} for participant ${this.participantIdentity}`,\n          CryptorErrorReason.MissingKey,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Function that will decrypt the given encoded frame. If the decryption fails, it will\n   * ratchet the key for up to RATCHET_WINDOW_SIZE times.\n   */\n  private async decryptFrame(\n    encodedFrame: RTCEncodedVideoFrame | RTCEncodedAudioFrame,\n    keyIndex: number,\n    initialMaterial: KeySet | undefined = undefined,\n    ratchetOpts: DecodeRatchetOptions = { ratchetCount: 0 },\n  ): Promise<RTCEncodedVideoFrame | RTCEncodedAudioFrame | undefined> {\n    const keySet = this.keys.getKeySet(keyIndex);\n    if (!ratchetOpts.encryptionKey && !keySet) {\n      throw new TypeError(`no encryption key found for decryption of ${this.participantIdentity}`);\n    }\n    let frameInfo = this.getUnencryptedBytes(encodedFrame);\n\n    // Construct frame trailer. Similar to the frame header described in\n    // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n    // but we put it at the end.\n    //\n    // ---------+-------------------------+-+---------+----\n    // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n    // ---------+-------------------------+-+---------+----\n\n    try {\n      const frameHeader = new Uint8Array(encodedFrame.data, 0, frameInfo.unencryptedBytes);\n      var encryptedData = new Uint8Array(\n        encodedFrame.data,\n        frameHeader.length,\n        encodedFrame.data.byteLength - frameHeader.length,\n      );\n      if (frameInfo.isH264 && needsRbspUnescaping(encryptedData)) {\n        encryptedData = parseRbsp(encryptedData);\n        const newUint8 = new Uint8Array(frameHeader.byteLength + encryptedData.byteLength);\n        newUint8.set(frameHeader);\n        newUint8.set(encryptedData, frameHeader.byteLength);\n        encodedFrame.data = newUint8.buffer;\n      }\n\n      const frameTrailer = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - 2, 2);\n\n      const ivLength = frameTrailer[0];\n      const iv = new Uint8Array(\n        encodedFrame.data,\n        encodedFrame.data.byteLength - ivLength - frameTrailer.byteLength,\n        ivLength,\n      );\n\n      const cipherTextStart = frameHeader.byteLength;\n      const cipherTextLength =\n        encodedFrame.data.byteLength -\n        (frameHeader.byteLength + ivLength + frameTrailer.byteLength);\n\n      const plainText = await crypto.subtle.decrypt(\n        {\n          name: ENCRYPTION_ALGORITHM,\n          iv,\n          additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength),\n        },\n        ratchetOpts.encryptionKey ?? keySet!.encryptionKey,\n        new Uint8Array(encodedFrame.data, cipherTextStart, cipherTextLength),\n      );\n\n      const newData = new ArrayBuffer(frameHeader.byteLength + plainText.byteLength);\n      const newUint8 = new Uint8Array(newData);\n\n      newUint8.set(new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength));\n      newUint8.set(new Uint8Array(plainText), frameHeader.byteLength);\n\n      encodedFrame.data = newData;\n\n      return encodedFrame;\n    } catch (error: any) {\n      if (this.keyProviderOptions.ratchetWindowSize > 0) {\n        if (ratchetOpts.ratchetCount < this.keyProviderOptions.ratchetWindowSize) {\n          workerLogger.debug(\n            `ratcheting key attempt ${ratchetOpts.ratchetCount} of ${\n              this.keyProviderOptions.ratchetWindowSize\n            }, for kind ${encodedFrame instanceof RTCEncodedAudioFrame ? 'audio' : 'video'}`,\n          );\n\n          let ratchetedKeySet: KeySet | undefined;\n          if ((initialMaterial ?? keySet) === this.keys.getKeySet(keyIndex)) {\n            // only ratchet if the currently set key is still the same as the one used to decrypt this frame\n            // if not, it might be that a different frame has already ratcheted and we try with that one first\n            const newMaterial = await this.keys.ratchetKey(keyIndex, false);\n\n            ratchetedKeySet = await deriveKeys(newMaterial, this.keyProviderOptions.ratchetSalt);\n          }\n\n          const frame = await this.decryptFrame(encodedFrame, keyIndex, initialMaterial || keySet, {\n            ratchetCount: ratchetOpts.ratchetCount + 1,\n            encryptionKey: ratchetedKeySet?.encryptionKey,\n          });\n          if (frame && ratchetedKeySet) {\n            // before updating the keys, make sure that the keySet used for this frame is still the same as the currently set key\n            // if it's not, a new key might have been set already, which we don't want to override\n            if ((initialMaterial ?? keySet) === this.keys.getKeySet(keyIndex)) {\n              this.keys.setKeySet(ratchetedKeySet, keyIndex, true);\n              // decryption was successful, set the new key index to reflect the ratcheted key set\n              this.keys.setCurrentKeyIndex(keyIndex);\n            }\n          }\n          return frame;\n        } else {\n          /**\n           * Because we only set a new key once decryption has been successful,\n           * we can be sure that we don't need to reset the key to the initial material at this point\n           * as the key has not been updated on the keyHandler instance\n           */\n\n          workerLogger.warn('maximum ratchet attempts exceeded');\n          throw new CryptorError(\n            `valid key missing for participant ${this.participantIdentity}`,\n            CryptorErrorReason.InvalidKey,\n          );\n        }\n      } else {\n        throw new CryptorError(\n          `Decryption failed: ${error.message}`,\n          CryptorErrorReason.InvalidKey,\n        );\n      }\n    }\n  }\n\n  /**\n   * Construct the IV used for AES-GCM and sent (in plain) with the packet similar to\n   * https://tools.ietf.org/html/rfc7714#section-8.1\n   * It concatenates\n   * - the 32 bit synchronization source (SSRC) given on the encoded frame,\n   * - the 32 bit rtp timestamp given on the encoded frame,\n   * - a send counter that is specific to the SSRC. Starts at a random number.\n   * The send counter is essentially the pictureId but we currently have to implement this ourselves.\n   * There is no XOR with a salt. Note that this IV leaks the SSRC to the receiver but since this is\n   * randomly generated and SFUs may not rewrite this is considered acceptable.\n   * The SSRC is used to allow demultiplexing multiple streams with the same key, as described in\n   *   https://tools.ietf.org/html/rfc3711#section-4.1.1\n   * The RTP timestamp is 32 bits and advances by the codec clock rate (90khz for video, 48khz for\n   * opus audio) every second. For video it rolls over roughly every 13 hours.\n   * The send counter will advance at the frame rate (30fps for video, 50fps for 20ms opus audio)\n   * every second. It will take a long time to roll over.\n   *\n   * See also https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n   */\n  private makeIV(synchronizationSource: number, timestamp: number) {\n    const iv = new ArrayBuffer(IV_LENGTH);\n    const ivView = new DataView(iv);\n\n    // having to keep our own send count (similar to a picture id) is not ideal.\n    if (!this.sendCounts.has(synchronizationSource)) {\n      // Initialize with a random offset, similar to the RTP sequence number.\n      this.sendCounts.set(synchronizationSource, Math.floor(Math.random() * 0xffff));\n    }\n\n    const sendCount = this.sendCounts.get(synchronizationSource) ?? 0;\n\n    ivView.setUint32(0, synchronizationSource);\n    ivView.setUint32(4, timestamp);\n    ivView.setUint32(8, timestamp - (sendCount % 0xffff));\n\n    this.sendCounts.set(synchronizationSource, sendCount + 1);\n\n    return iv;\n  }\n\n  private getUnencryptedBytes(frame: RTCEncodedVideoFrame | RTCEncodedAudioFrame): {\n    unencryptedBytes: number;\n    isH264: boolean;\n  } {\n    var frameInfo = { unencryptedBytes: 0, isH264: false };\n    if (isVideoFrame(frame)) {\n      let detectedCodec = this.getVideoCodec(frame) ?? this.videoCodec;\n      if (detectedCodec !== this.detectedCodec) {\n        workerLogger.debug('detected different codec', {\n          detectedCodec,\n          oldCodec: this.detectedCodec,\n          ...this.logContext,\n        });\n        this.detectedCodec = detectedCodec;\n      }\n\n      if (detectedCodec === 'av1' || detectedCodec === 'vp9') {\n        throw new Error(`${detectedCodec} is not yet supported for end to end encryption`);\n      }\n\n      if (detectedCodec === 'vp8') {\n        frameInfo.unencryptedBytes = UNENCRYPTED_BYTES[frame.type];\n        return frameInfo;\n      }\n\n      const data = new Uint8Array(frame.data);\n      try {\n        const naluIndices = findNALUIndices(data);\n\n        // if the detected codec is undefined we test whether it _looks_ like a h264 frame as a best guess\n        frameInfo.isH264 =\n          detectedCodec === 'h264' ||\n          naluIndices.some((naluIndex) =>\n            [NALUType.SLICE_IDR, NALUType.SLICE_NON_IDR].includes(parseNALUType(data[naluIndex])),\n          );\n\n        if (frameInfo.isH264) {\n          for (const index of naluIndices) {\n            let type = parseNALUType(data[index]);\n            switch (type) {\n              case NALUType.SLICE_IDR:\n              case NALUType.SLICE_NON_IDR:\n                frameInfo.unencryptedBytes = index + 2;\n                return frameInfo;\n              default:\n                break;\n            }\n          }\n          throw new TypeError('Could not find NALU');\n        }\n      } catch (e) {\n        // no op, we just continue and fallback to vp8\n      }\n\n      frameInfo.unencryptedBytes = UNENCRYPTED_BYTES[frame.type];\n      return frameInfo;\n    } else {\n      frameInfo.unencryptedBytes = UNENCRYPTED_BYTES.audio;\n      return frameInfo;\n    }\n  }\n\n  /**\n   * inspects frame payloadtype if available and maps it to the codec specified in rtpMap\n   */\n  private getVideoCodec(frame: RTCEncodedVideoFrame): VideoCodec | undefined {\n    if (this.rtpMap.size === 0) {\n      return undefined;\n    }\n    // @ts-expect-error payloadType is not yet part of the typescript definition and currently not supported in Safari\n    const payloadType = frame.getMetadata().payloadType;\n    const codec = payloadType ? this.rtpMap.get(payloadType) : undefined;\n    return codec;\n  }\n}\n\n/**\n * Slice the NALUs present in the supplied buffer, assuming it is already byte-aligned\n * code adapted from https://github.com/medooze/h264-frame-parser/blob/main/lib/NalUnits.ts to return indices only\n */\nexport function findNALUIndices(stream: Uint8Array): number[] {\n  const result: number[] = [];\n  let start = 0,\n    pos = 0,\n    searchLength = stream.length - 2;\n  while (pos < searchLength) {\n    // skip until end of current NALU\n    while (\n      pos < searchLength &&\n      !(stream[pos] === 0 && stream[pos + 1] === 0 && stream[pos + 2] === 1)\n    )\n      pos++;\n    if (pos >= searchLength) pos = stream.length;\n    // remove trailing zeros from current NALU\n    let end = pos;\n    while (end > start && stream[end - 1] === 0) end--;\n    // save current NALU\n    if (start === 0) {\n      if (end !== start) throw TypeError('byte stream contains leading data');\n    } else {\n      result.push(start);\n    }\n    // begin new NALU\n    start = pos = pos + 3;\n  }\n  return result;\n}\n\nexport function parseNALUType(startByte: number): NALUType {\n  return startByte & kNaluTypeMask;\n}\n\nconst kNaluTypeMask = 0x1f;\n\nexport enum NALUType {\n  /** Coded slice of a non-IDR picture */\n  SLICE_NON_IDR = 1,\n  /** Coded slice data partition A */\n  SLICE_PARTITION_A = 2,\n  /** Coded slice data partition B */\n  SLICE_PARTITION_B = 3,\n  /** Coded slice data partition C */\n  SLICE_PARTITION_C = 4,\n  /** Coded slice of an IDR picture */\n  SLICE_IDR = 5,\n  /** Supplemental enhancement information */\n  SEI = 6,\n  /** Sequence parameter set */\n  SPS = 7,\n  /** Picture parameter set */\n  PPS = 8,\n  /** Access unit delimiter */\n  AUD = 9,\n  /** End of sequence */\n  END_SEQ = 10,\n  /** End of stream */\n  END_STREAM = 11,\n  /** Filler data */\n  FILLER_DATA = 12,\n  /** Sequence parameter set extension */\n  SPS_EXT = 13,\n  /** Prefix NAL unit */\n  PREFIX_NALU = 14,\n  /** Subset sequence parameter set */\n  SUBSET_SPS = 15,\n  /** Depth parameter set */\n  DPS = 16,\n\n  // 17, 18 reserved\n\n  /** Coded slice of an auxiliary coded picture without partitioning */\n  SLICE_AUX = 19,\n  /** Coded slice extension */\n  SLICE_EXT = 20,\n  /** Coded slice extension for a depth view component or a 3D-AVC texture view component */\n  SLICE_LAYER_EXT = 21,\n\n  // 22, 23 reserved\n}\n\n/**\n * we use a magic frame trailer to detect whether a frame is injected\n * by the livekit server and thus to be treated as unencrypted\n * @internal\n */\nexport function isFrameServerInjected(frameData: ArrayBuffer, trailerBytes: Uint8Array): boolean {\n  if (trailerBytes.byteLength === 0) {\n    return false;\n  }\n  const frameTrailer = new Uint8Array(\n    frameData.slice(frameData.byteLength - trailerBytes.byteLength),\n  );\n  return trailerBytes.every((value, index) => value === frameTrailer[index]);\n}\n","import { EventEmitter } from 'events';\nimport type TypedEventEmitter from 'typed-emitter';\nimport { workerLogger } from '../../logger';\nimport { KEYRING_SIZE } from '../constants';\nimport { KeyHandlerEvent, type ParticipantKeyHandlerCallbacks } from '../events';\nimport type { KeyProviderOptions, KeySet } from '../types';\nimport { deriveKeys, importKey, ratchet } from '../utils';\n\n// TODO ParticipantKeyHandlers currently don't get destroyed on participant disconnect\n// we could do this by having a separate worker message on participant disconnected.\n\n/**\n * ParticipantKeyHandler is responsible for providing a cryptor instance with the\n * en-/decryption key of a participant. It assumes that all tracks of a specific participant\n * are encrypted with the same key.\n * Additionally it exposes a method to ratchet a key which can be used by the cryptor either automatically\n * if decryption fails or can be triggered manually on both sender and receiver side.\n *\n */\nexport class ParticipantKeyHandler extends (EventEmitter as new () => TypedEventEmitter<ParticipantKeyHandlerCallbacks>) {\n  private currentKeyIndex: number;\n\n  private cryptoKeyRing: Array<KeySet | undefined>;\n\n  private keyProviderOptions: KeyProviderOptions;\n\n  private ratchetPromiseMap: Map<number, Promise<CryptoKey>>;\n\n  private participantIdentity: string;\n\n  private decryptionFailureCount = 0;\n\n  private _hasValidKey: boolean = true;\n\n  get hasValidKey() {\n    return this._hasValidKey;\n  }\n\n  constructor(participantIdentity: string, keyProviderOptions: KeyProviderOptions) {\n    super();\n    this.currentKeyIndex = 0;\n    this.cryptoKeyRing = new Array(KEYRING_SIZE).fill(undefined);\n    this.keyProviderOptions = keyProviderOptions;\n    this.ratchetPromiseMap = new Map();\n    this.participantIdentity = participantIdentity;\n    this.resetKeyStatus();\n  }\n\n  decryptionFailure() {\n    if (this.keyProviderOptions.failureTolerance < 0) {\n      return;\n    }\n    this.decryptionFailureCount += 1;\n\n    if (this.decryptionFailureCount > this.keyProviderOptions.failureTolerance) {\n      workerLogger.warn(`key for ${this.participantIdentity} is being marked as invalid`);\n      this._hasValidKey = false;\n    }\n  }\n\n  decryptionSuccess() {\n    this.resetKeyStatus();\n  }\n\n  /**\n   * Call this after user initiated ratchet or a new key has been set in order to make sure to mark potentially\n   * invalid keys as valid again\n   */\n  resetKeyStatus() {\n    this.decryptionFailureCount = 0;\n    this._hasValidKey = true;\n  }\n\n  /**\n   * Ratchets the current key (or the one at keyIndex if provided) and\n   * returns the ratcheted material\n   * if `setKey` is true (default), it will also set the ratcheted key directly on the crypto key ring\n   * @param keyIndex\n   * @param setKey\n   */\n  ratchetKey(keyIndex?: number, setKey = true): Promise<CryptoKey> {\n    const currentKeyIndex = keyIndex ?? this.getCurrentKeyIndex();\n\n    const existingPromise = this.ratchetPromiseMap.get(currentKeyIndex);\n    if (typeof existingPromise !== 'undefined') {\n      return existingPromise;\n    }\n    const ratchetPromise = new Promise<CryptoKey>(async (resolve, reject) => {\n      try {\n        const keySet = this.getKeySet(currentKeyIndex);\n        if (!keySet) {\n          throw new TypeError(\n            `Cannot ratchet key without a valid keyset of participant ${this.participantIdentity}`,\n          );\n        }\n        const currentMaterial = keySet.material;\n        const newMaterial = await importKey(\n          await ratchet(currentMaterial, this.keyProviderOptions.ratchetSalt),\n          currentMaterial.algorithm.name,\n          'derive',\n        );\n\n        if (setKey) {\n          this.setKeyFromMaterial(newMaterial, currentKeyIndex, true);\n          this.emit(\n            KeyHandlerEvent.KeyRatcheted,\n            newMaterial,\n            this.participantIdentity,\n            currentKeyIndex,\n          );\n        }\n        resolve(newMaterial);\n      } catch (e) {\n        reject(e);\n      } finally {\n        this.ratchetPromiseMap.delete(currentKeyIndex);\n      }\n    });\n    this.ratchetPromiseMap.set(currentKeyIndex, ratchetPromise);\n    return ratchetPromise;\n  }\n\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffer\n   * together with the material\n   * also resets the valid key property and updates the currentKeyIndex\n   */\n  async setKey(material: CryptoKey, keyIndex = 0) {\n    await this.setKeyFromMaterial(material, keyIndex);\n    this.resetKeyStatus();\n  }\n\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffers\n   * together with the material\n   * also updates the currentKeyIndex\n   */\n  async setKeyFromMaterial(material: CryptoKey, keyIndex: number, emitRatchetEvent = false) {\n    const keySet = await deriveKeys(material, this.keyProviderOptions.ratchetSalt);\n    const newIndex = keyIndex >= 0 ? keyIndex % this.cryptoKeyRing.length : this.currentKeyIndex;\n    workerLogger.debug(`setting new key with index ${keyIndex}`, {\n      usage: material.usages,\n      algorithm: material.algorithm,\n      ratchetSalt: this.keyProviderOptions.ratchetSalt,\n    });\n    this.setKeySet(keySet, newIndex, emitRatchetEvent);\n    if (newIndex >= 0) this.currentKeyIndex = newIndex;\n  }\n\n  setKeySet(keySet: KeySet, keyIndex: number, emitRatchetEvent = false) {\n    this.cryptoKeyRing[keyIndex % this.cryptoKeyRing.length] = keySet;\n\n    if (emitRatchetEvent) {\n      this.emit(KeyHandlerEvent.KeyRatcheted, keySet.material, this.participantIdentity, keyIndex);\n    }\n  }\n\n  async setCurrentKeyIndex(index: number) {\n    this.currentKeyIndex = index % this.cryptoKeyRing.length;\n    this.resetKeyStatus();\n  }\n\n  getCurrentKeyIndex() {\n    return this.currentKeyIndex;\n  }\n\n  /**\n   * returns currently used KeySet or the one at `keyIndex` if provided\n   * @param keyIndex\n   * @returns\n   */\n  getKeySet(keyIndex?: number) {\n    return this.cryptoKeyRing[keyIndex ?? this.currentKeyIndex];\n  }\n}\n","import { workerLogger } from '../../logger';\nimport { KEY_PROVIDER_DEFAULTS } from '../constants';\nimport { CryptorErrorReason } from '../errors';\nimport { CryptorEvent, KeyHandlerEvent } from '../events';\nimport type {\n  E2EEWorkerMessage,\n  ErrorMessage,\n  InitAck,\n  KeyProviderOptions,\n  RatchetMessage,\n  RatchetRequestMessage,\n} from '../types';\nimport { FrameCryptor, encryptionEnabledMap } from './FrameCryptor';\nimport { ParticipantKeyHandler } from './ParticipantKeyHandler';\n\nconst participantCryptors: FrameCryptor[] = [];\nconst participantKeys: Map<string, ParticipantKeyHandler> = new Map();\nlet sharedKeyHandler: ParticipantKeyHandler | undefined;\n\nlet isEncryptionEnabled: boolean = false;\n\nlet useSharedKey: boolean = false;\n\nlet sifTrailer: Uint8Array | undefined;\n\nlet keyProviderOptions: KeyProviderOptions = KEY_PROVIDER_DEFAULTS;\n\nworkerLogger.setDefaultLevel('info');\n\nonmessage = (ev) => {\n  const { kind, data }: E2EEWorkerMessage = ev.data;\n\n  switch (kind) {\n    case 'init':\n      workerLogger.setLevel(data.loglevel);\n      workerLogger.info('worker initialized');\n      keyProviderOptions = data.keyProviderOptions;\n      useSharedKey = !!data.keyProviderOptions.sharedKey;\n      // acknowledge init successful\n      const ackMsg: InitAck = {\n        kind: 'initAck',\n        data: { enabled: isEncryptionEnabled },\n      };\n      postMessage(ackMsg);\n      break;\n    case 'enable':\n      setEncryptionEnabled(data.enabled, data.participantIdentity);\n      workerLogger.info('updated e2ee enabled status');\n      // acknowledge enable call successful\n      postMessage(ev.data);\n      break;\n    case 'decode':\n      let cryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n      cryptor.setupTransform(\n        kind,\n        data.readableStream,\n        data.writableStream,\n        data.trackId,\n        data.codec,\n      );\n      break;\n    case 'encode':\n      let pubCryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n      pubCryptor.setupTransform(\n        kind,\n        data.readableStream,\n        data.writableStream,\n        data.trackId,\n        data.codec,\n      );\n      break;\n    case 'setKey':\n      if (useSharedKey) {\n        setSharedKey(data.key, data.keyIndex);\n      } else if (data.participantIdentity) {\n        workerLogger.info(\n          `set participant sender key ${data.participantIdentity} index ${data.keyIndex}`,\n        );\n        getParticipantKeyHandler(data.participantIdentity).setKey(data.key, data.keyIndex);\n      } else {\n        workerLogger.error('no participant Id was provided and shared key usage is disabled');\n      }\n      break;\n    case 'removeTransform':\n      unsetCryptorParticipant(data.trackId, data.participantIdentity);\n      break;\n    case 'updateCodec':\n      getTrackCryptor(data.participantIdentity, data.trackId).setVideoCodec(data.codec);\n      break;\n    case 'setRTPMap':\n      // this is only used for the local participant\n      participantCryptors.forEach((cr) => {\n        if (cr.getParticipantIdentity() === data.participantIdentity) {\n          cr.setRtpMap(data.map);\n        }\n      });\n      break;\n    case 'ratchetRequest':\n      handleRatchetRequest(data);\n      break;\n    case 'setSifTrailer':\n      handleSifTrailer(data.trailer);\n      break;\n    default:\n      break;\n  }\n};\n\nasync function handleRatchetRequest(data: RatchetRequestMessage['data']) {\n  if (useSharedKey) {\n    const keyHandler = getSharedKeyHandler();\n    await keyHandler.ratchetKey(data.keyIndex);\n    keyHandler.resetKeyStatus();\n  } else if (data.participantIdentity) {\n    const keyHandler = getParticipantKeyHandler(data.participantIdentity);\n    await keyHandler.ratchetKey(data.keyIndex);\n    keyHandler.resetKeyStatus();\n  } else {\n    workerLogger.error(\n      'no participant Id was provided for ratchet request and shared key usage is disabled',\n    );\n  }\n}\n\nfunction getTrackCryptor(participantIdentity: string, trackId: string) {\n  let cryptor = participantCryptors.find((c) => c.getTrackId() === trackId);\n  if (!cryptor) {\n    workerLogger.info('creating new cryptor for', { participantIdentity });\n    if (!keyProviderOptions) {\n      throw Error('Missing keyProvider options');\n    }\n    cryptor = new FrameCryptor({\n      participantIdentity,\n      keys: getParticipantKeyHandler(participantIdentity),\n      keyProviderOptions,\n      sifTrailer,\n    });\n\n    setupCryptorErrorEvents(cryptor);\n    participantCryptors.push(cryptor);\n  } else if (participantIdentity !== cryptor.getParticipantIdentity()) {\n    // assign new participant id to track cryptor and pass in correct key handler\n    cryptor.setParticipant(participantIdentity, getParticipantKeyHandler(participantIdentity));\n  }\n\n  return cryptor;\n}\n\nfunction getParticipantKeyHandler(participantIdentity: string) {\n  if (useSharedKey) {\n    return getSharedKeyHandler();\n  }\n  let keys = participantKeys.get(participantIdentity);\n  if (!keys) {\n    keys = new ParticipantKeyHandler(participantIdentity, keyProviderOptions);\n    keys.on(KeyHandlerEvent.KeyRatcheted, emitRatchetedKeys);\n    participantKeys.set(participantIdentity, keys);\n  }\n  return keys;\n}\n\nfunction getSharedKeyHandler() {\n  if (!sharedKeyHandler) {\n    workerLogger.debug('creating new shared key handler');\n    sharedKeyHandler = new ParticipantKeyHandler('shared-key', keyProviderOptions);\n  }\n  return sharedKeyHandler;\n}\n\nfunction unsetCryptorParticipant(trackId: string, participantIdentity: string) {\n  const cryptor = participantCryptors.find(\n    (c) => c.getParticipantIdentity() === participantIdentity && c.getTrackId() === trackId,\n  );\n  if (!cryptor) {\n    workerLogger.warn('Could not unset participant on cryptor', { trackId, participantIdentity });\n  } else {\n    cryptor.unsetParticipant();\n  }\n}\n\nfunction setEncryptionEnabled(enable: boolean, participantIdentity: string) {\n  workerLogger.debug(`setting encryption enabled for all tracks of ${participantIdentity}`, {\n    enable,\n  });\n  encryptionEnabledMap.set(participantIdentity, enable);\n}\n\nfunction setSharedKey(key: CryptoKey, index?: number) {\n  workerLogger.info('set shared key', { index });\n  getSharedKeyHandler().setKey(key, index);\n}\n\nfunction setupCryptorErrorEvents(cryptor: FrameCryptor) {\n  cryptor.on(CryptorEvent.Error, (error) => {\n    const msg: ErrorMessage = {\n      kind: 'error',\n      data: { error: new Error(`${CryptorErrorReason[error.reason]}: ${error.message}`) },\n    };\n    postMessage(msg);\n  });\n}\n\nfunction emitRatchetedKeys(material: CryptoKey, participantIdentity: string, keyIndex?: number) {\n  const msg: RatchetMessage = {\n    kind: `ratchetKey`,\n    data: {\n      participantIdentity,\n      keyIndex,\n      material,\n    },\n  };\n  postMessage(msg);\n}\n\nfunction handleSifTrailer(trailer: Uint8Array) {\n  sifTrailer = trailer;\n  participantCryptors.forEach((c) => {\n    c.setSifTrailer(trailer);\n  });\n}\n\n// Operations using RTCRtpScriptTransform.\n// @ts-ignore\nif (self.RTCTransformEvent) {\n  workerLogger.debug('setup transform event');\n  // @ts-ignore\n  self.onrtctransform = (event) => {\n    const transformer = event.transformer;\n    workerLogger.debug('transformer', transformer);\n    transformer.handled = true;\n    const { kind, participantIdentity, trackId, codec } = transformer.options;\n    const cryptor = getTrackCryptor(participantIdentity, trackId);\n    workerLogger.debug('transform', { codec });\n    cryptor.setupTransform(kind, transformer.readable, transformer.writable, trackId, codec);\n  };\n}\n"],"names":["root","definition","this","noop","undefinedType","isIE","window","navigator","test","userAgent","logMethods","bindMethod","obj","methodName","method","bind","Function","prototype","call","e","apply","arguments","traceForIE","console","log","trace","replaceLoggingMethods","level","loggerName","i","length","methodFactory","debug","enableLoggingWhenConsoleArrives","defaultMethodFactory","undefined","realMethod","Logger","name","defaultLevel","factory","currentLevel","self","storageKey","getPersistedLevel","storedLevel","localStorage","ignore","cookie","document","location","indexOf","encodeURIComponent","exec","slice","levels","TRACE","DEBUG","INFO","WARN","ERROR","SILENT","getLevel","setLevel","persist","toUpperCase","levelNum","levelName","persistLevelIfPossible","setDefaultLevel","resetLevel","removeItem","clearPersistedLevel","enableAll","disableAll","initialLevel","defaultLogger","_loggersByName","getLogger","TypeError","logger","_log","noConflict","getLoggers","exports","module","LogLevel","LoggerNames","livekitLogger","Object","values","map","info","workerLogger","ENCRYPTION_ALGORITHM","UNENCRYPTED_BYTES","key","delta","audio","empty","KEY_PROVIDER_DEFAULTS","sharedKey","ratchetSalt","ratchetWindowSize","failureTolerance","LivekitError","Error","constructor","code","message","super","MediaDeviceFailure","CryptorErrorReason","KeyProviderEvent","KeyHandlerEvent","EncryptionEvent","CryptorEvent","getFailure","error","NotFound","PermissionDenied","DeviceInUse","Other","CryptorError","reason","InternalError","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","args","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","concat","NumberIsNaN","Number","isNaN","value","EventEmitter","init","eventsModule","once","emitter","Promise","resolve","reject","errorListener","err","removeListener","resolver","eventTargetAgnosticAddListener","handler","flags","on","addErrorHandlerIfEventEmitter","_events","_eventsCount","_maxListeners","defaultMaxListeners","checkListener","listener","_getMaxListeners","that","_addListener","type","prepend","m","events","existing","warning","create","newListener","emit","unshift","push","warned","w","String","count","warn","onceWrapper","fired","wrapFn","_onceWrap","state","wrapped","_listeners","unwrap","evlistener","arr","ret","Array","unwrapListeners","arrayClone","listenerCount","n","copy","addEventListener","wrapListener","arg","removeEventListener","defineProperty","enumerable","get","set","RangeError","getPrototypeOf","setMaxListeners","getMaxListeners","doError","er","context","len","listeners","addListener","prependListener","prependOnceListener","list","position","originalListener","shift","index","pop","spliceOne","off","removeAllListeners","keys","rawListeners","eventNames","getAlgoOptions","algorithmName","salt","encodedSalt","TextEncoder","encode","hash","ArrayBuffer","iterations","deriveKeys","material","algorithmOptions","algorithm","encryptionKey","crypto","subtle","deriveKey","SifGuard","consecutiveSifCount","lastSifReceivedAt","userFramesSinceSif","recordSif","_a","sifSequenceStartedAt","Date","now","recordUserFrame","reset","isSifAllowed","encryptionEnabledMap","Map","BaseFrameCryptor","encodeFunction","encodedFrame","controller","decodeFunction","FrameCryptor","opts","sendCounts","participantIdentity","rtpMap","keyProviderOptions","sifTrailer","Uint8Array","from","sifGuard","logContext","participant","mediaTrackId","trackId","fallbackCodec","videoCodec","setParticipant","id","unsetParticipant","isEnabled","getParticipantIdentity","getTrackId","setVideoCodec","codec","setRtpMap","setupTransform","operation","readable","writable","assign","passedTrackId","transformFn","transformStream","TransformStream","transform","pipeThrough","pipeTo","catch","setSifTrailer","trailer","data","byteLength","enqueue","keySet","getKeySet","getCurrentKeyIndex","keyIndex","iv","makeIV","getMetadata","synchronizationSource","timestamp","frameInfo","getUnencryptedBytes","frameHeader","unencryptedBytes","frameTrailer","cipherText","encrypt","additionalData","newDataWithoutHeader","isH264","data_in","dataOut","numConsecutiveZeros","byte","writeRbsp","newData","buffer","MissingKey","frameData","trailerBytes","every","isFrameServerInjected","hasValidKey","decodedFrame","decryptFrame","decryptionSuccess","InvalidKey","decryptionFailure","initialMaterial","ratchetOpts","ratchetCount","encryptedData","needsRbspUnescaping","stream","parseRbsp","newUint8","ivLength","cipherTextStart","cipherTextLength","plainText","decrypt","ratchetedKeySet","RTCEncodedAudioFrame","newMaterial","ratchetKey","frame","setKeySet","setCurrentKeyIndex","ivView","DataView","has","Math","floor","random","sendCount","setUint32","isVideoFrame","detectedCodec","getVideoCodec","oldCodec","naluIndices","result","start","pos","searchLength","end","findNALUIndices","some","naluIndex","NALUType","SLICE_IDR","SLICE_NON_IDR","includes","parseNALUType","size","payloadType","startByte","kNaluTypeMask","ParticipantKeyHandler","_hasValidKey","decryptionFailureCount","currentKeyIndex","cryptoKeyRing","fill","ratchetPromiseMap","resetKeyStatus","setKey","existingPromise","ratchetPromise","__awaiter","currentMaterial","keyBytes","usage","importKey","deriveBits","ratchet","setKeyFromMaterial","KeyRatcheted","delete","emitRatchetEvent","newIndex","usages","participantCryptors","participantKeys","sharedKeyHandler","useSharedKey","getTrackCryptor","cryptor","find","c","getParticipantKeyHandler","msg","kind","postMessage","setupCryptorErrorEvents","getSharedKeyHandler","emitRatchetedKeys","onmessage","ev","loglevel","enabled","enable","readableStream","writableStream","unsetCryptorParticipant","forEach","cr","keyHandler","handleRatchetRequest","RTCTransformEvent","onrtctransform","event","transformer","handled","options"],"mappings":"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","x_google_ignoreList":[0,6]}